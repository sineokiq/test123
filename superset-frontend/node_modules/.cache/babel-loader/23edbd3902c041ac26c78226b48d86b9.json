{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";import _sortInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/sort\";import _concatInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/concat\";import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";import _Object$keys from \"@babel/runtime-corejs3/core-js-stable/object/keys\";import _filterInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/filter\";import _mapInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/map\";import _reduceInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/reduce\";import _Array$isArray from \"@babel/runtime-corejs3/core-js-stable/array/is-array\";import _Object$values from \"@babel/runtime-corejs3/core-js-stable/object/values\";import _Set from \"@babel/runtime-corejs3/core-js-stable/set\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { getChartIdsInFilterScope } from '../../util/activeDashboardFilters';\nimport { TIME_FILTER_MAP } from '../../../visualizations/FilterBox/FilterBox';\nexport var IndicatorStatus;\n(function (IndicatorStatus) {\n  IndicatorStatus[\"Unset\"] = \"UNSET\";\n  IndicatorStatus[\"Applied\"] = \"APPLIED\";\n  IndicatorStatus[\"Incompatible\"] = \"INCOMPATIBLE\";\n})(IndicatorStatus || (IndicatorStatus = {}));\nconst TIME_GRANULARITY_FIELDS = new _Set(_Object$values(TIME_FILTER_MAP));\nconst selectIndicatorValue = (columnKey, filter, datasource) => {\n  const values = filter.columns[columnKey];\n  const arrValues = _Array$isArray(values) ? values : [values];\n  if (values == null ||\n  filter.isDateFilter && values === 'No filter' ||\n  arrValues.length === 0) {\n    return [];\n  }\n  if (filter.isDateFilter && TIME_GRANULARITY_FIELDS.has(columnKey)) {var _context;\n    const timeGranularityMap = _reduceInstanceProperty(_context = (columnKey === TIME_FILTER_MAP.time_grain_sqla ?\n    datasource.time_grain_sqla :\n    datasource.granularity) || []).call(_context, (map, [key, value]) => ({\n      ...map,\n      [key]: value }),\n    {});\n    return _mapInstanceProperty(arrValues).call(arrValues, value => timeGranularityMap[value] || value);\n  }\n  return arrValues;\n};\nconst selectIndicatorsForChartFromFilter = (chartId, filter, filterDataSource, appliedColumns, rejectedColumns) => {var _context2, _context3;\n  // filters can be applied (if the filter is compatible with the datasource)\n  // or rejected (if the filter is incompatible)\n  // or the status can be unknown (if the filter has calculated parameters that we can't analyze)\n  const getStatus = column => {\n    if (appliedColumns.has(column))\n    return IndicatorStatus.Applied;\n    if (rejectedColumns.has(column))\n    return IndicatorStatus.Incompatible;\n    return IndicatorStatus.Unset;\n  };\n  return _mapInstanceProperty(_context2 = _filterInstanceProperty(_context3 = _Object$keys(filter.columns)).call(_context3,\n  column => {var _context4;return _includesInstanceProperty(_context4 = getChartIdsInFilterScope({\n      filterScope: filter.scopes[column] })).call(_context4,\n    chartId);})).call(_context2,\n  column => ({\n    column,\n    name: filter.labels[column] || column,\n    value: selectIndicatorValue(column, filter, filterDataSource),\n    status: getStatus(column),\n    path: filter.directPathToFilter }));\n\n};\n// inspects redux state to find what the filter indicators should be shown for a given chart\nexport const selectIndicatorsForChart = (chartId, filters, datasources, charts) => {var _context5, _chart$queriesRespons, _chart$queriesRespons2, _context6, _chart$queriesRespons3, _chart$queriesRespons4, _context7, _context8;\n  const chart = charts[chartId];\n  // no indicators if chart is loading\n  if (chart.chartStatus === 'loading')\n  return [];\n  // for now we only need to know which columns are compatible/incompatible,\n  // so grab the columns from the applied/rejected filters\n  const appliedColumns = new _Set(_mapInstanceProperty(_context5 = (chart == null ? void 0 : (_chart$queriesRespons = chart.queriesResponse) == null ? void 0 : (_chart$queriesRespons2 = _chart$queriesRespons[0]) == null ? void 0 : _chart$queriesRespons2.applied_filters) || []).call(_context5, filter => filter.column));\n  const rejectedColumns = new _Set(_mapInstanceProperty(_context6 = (chart == null ? void 0 : (_chart$queriesRespons3 = chart.queriesResponse) == null ? void 0 : (_chart$queriesRespons4 = _chart$queriesRespons3[0]) == null ? void 0 : _chart$queriesRespons4.rejected_filters) || []).call(_context6, filter => filter.column));\n  const indicators = _reduceInstanceProperty(_context7 = _filterInstanceProperty(_context8 = _Object$values(filters)).call(_context8,\n  filter => filter.chartId !== chartId)).call(_context7,\n  (acc, filter) => _concatInstanceProperty(acc).call(acc, selectIndicatorsForChartFromFilter(chartId, filter, datasources[filter.datasourceId] || {}, appliedColumns, rejectedColumns)), []);\n  _sortInstanceProperty(indicators).call(indicators, (a, b) => a.name.localeCompare(b.name));\n  return indicators;\n};;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(IndicatorStatus, \"IndicatorStatus\", \"/app/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts\");reactHotLoader.register(TIME_GRANULARITY_FIELDS, \"TIME_GRANULARITY_FIELDS\", \"/app/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts\");reactHotLoader.register(selectIndicatorValue, \"selectIndicatorValue\", \"/app/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts\");reactHotLoader.register(selectIndicatorsForChartFromFilter, \"selectIndicatorsForChartFromFilter\", \"/app/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts\");reactHotLoader.register(selectIndicatorsForChart, \"selectIndicatorsForChart\", \"/app/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/app/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { getChartIdsInFilterScope } from '../../util/activeDashboardFilters';\nimport { TIME_FILTER_MAP } from '../../../visualizations/FilterBox/FilterBox';\n\nexport enum IndicatorStatus {\n  Unset = 'UNSET',\n  Applied = 'APPLIED',\n  Incompatible = 'INCOMPATIBLE',\n}\n\nconst TIME_GRANULARITY_FIELDS = new Set(Object.values(TIME_FILTER_MAP));\n\n// As of 2020-09-28, the DatasourceMeta type in superset-ui is incorrect.\n// Should patch it here until the DatasourceMeta type is updated.\ntype Datasource = {\n  time_grain_sqla?: [string, string][];\n  granularity?: [string, string][];\n};\n\ntype Filter = {\n  chartId: number;\n  columns: { [key: string]: string | string[] };\n  scopes: { [key: string]: any };\n  labels: { [key: string]: string };\n  isDateFilter: boolean;\n  directPathToFilter: string[];\n  datasourceId: string;\n};\n\nconst selectIndicatorValue = (\n  columnKey: string,\n  filter: Filter,\n  datasource: Datasource,\n): string[] => {\n  const values = filter.columns[columnKey];\n  const arrValues = Array.isArray(values) ? values : [values];\n\n  if (\n    values == null ||\n    (filter.isDateFilter && values === 'No filter') ||\n    arrValues.length === 0\n  ) {\n    return [];\n  }\n\n  if (filter.isDateFilter && TIME_GRANULARITY_FIELDS.has(columnKey)) {\n    const timeGranularityMap = (\n      (columnKey === TIME_FILTER_MAP.time_grain_sqla\n        ? datasource.time_grain_sqla\n        : datasource.granularity) || []\n    ).reduce(\n      (map, [key, value]) => ({\n        ...map,\n        [key]: value,\n      }),\n      {},\n    );\n\n    return arrValues.map(value => timeGranularityMap[value] || value);\n  }\n\n  return arrValues;\n};\n\nconst selectIndicatorsForChartFromFilter = (\n  chartId: number,\n  filter: Filter,\n  filterDataSource: Datasource,\n  appliedColumns: Set<string>,\n  rejectedColumns: Set<string>,\n): Indicator[] => {\n  // filters can be applied (if the filter is compatible with the datasource)\n  // or rejected (if the filter is incompatible)\n  // or the status can be unknown (if the filter has calculated parameters that we can't analyze)\n  const getStatus = (column: string) => {\n    if (appliedColumns.has(column)) return IndicatorStatus.Applied;\n    if (rejectedColumns.has(column)) return IndicatorStatus.Incompatible;\n    return IndicatorStatus.Unset;\n  };\n\n  return Object.keys(filter.columns)\n    .filter(column =>\n      getChartIdsInFilterScope({\n        filterScope: filter.scopes[column],\n      }).includes(chartId),\n    )\n    .map(column => ({\n      column,\n      name: filter.labels[column] || column,\n      value: selectIndicatorValue(column, filter, filterDataSource),\n      status: getStatus(column),\n      path: filter.directPathToFilter,\n    }));\n};\n\nexport type Indicator = {\n  column: string;\n  name: string;\n  value: string[];\n  status: IndicatorStatus;\n  path: string[];\n};\n\n// inspects redux state to find what the filter indicators should be shown for a given chart\nexport const selectIndicatorsForChart = (\n  chartId: number,\n  filters: { [key: number]: Filter },\n  datasources: { [key: string]: Datasource },\n  charts: any,\n): Indicator[] => {\n  const chart = charts[chartId];\n  // no indicators if chart is loading\n  if (chart.chartStatus === 'loading') return [];\n\n  // for now we only need to know which columns are compatible/incompatible,\n  // so grab the columns from the applied/rejected filters\n  const appliedColumns: Set<string> = new Set(\n    (chart?.queriesResponse?.[0]?.applied_filters || []).map(\n      (filter: any) => filter.column,\n    ),\n  );\n  const rejectedColumns: Set<string> = new Set(\n    (chart?.queriesResponse?.[0]?.rejected_filters || []).map(\n      (filter: any) => filter.column,\n    ),\n  );\n  const indicators = Object.values(filters)\n    .filter(filter => filter.chartId !== chartId)\n    .reduce(\n      (acc, filter) =>\n        acc.concat(\n          selectIndicatorsForChartFromFilter(\n            chartId,\n            filter,\n            datasources[filter.datasourceId] || {},\n            appliedColumns,\n            rejectedColumns,\n          ),\n        ),\n      [] as Indicator[],\n    );\n  indicators.sort((a, b) => a.name.localeCompare(b.name));\n  return indicators;\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}