{"ast":null,"code":"import _isEqual from \"lodash/isEqual\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { CategoricalColorNamespace } from '@superset-ui/core';\nimport { getExtraFormData } from 'src/dashboard/components/nativeFilters/utils';\nimport getEffectiveExtraFilters from './getEffectiveExtraFilters';\n// We cache formData objects so that our connected container components don't always trigger\n// render cascades. we cannot leverage the reselect library because our cache size is >1\nconst cachedFiltersByChart = {};\nconst cachedFormdataByChart = {};\n// this function merge chart's formData with dashboard filters value,\n// and generate a new formData which will be used in the new query.\n// filters param only contains those applicable to this chart.\nexport default function getFormDataWithExtraFilters({ chart, filters, colorScheme, colorNamespace, sliceId, nativeFilters }) {\n  // Propagate color mapping to chart\n  const scale = CategoricalColorNamespace.getScale(colorScheme, colorNamespace);\n  const labelColors = scale.getColorMap();\n  // if dashboard metadata + filters have not changed, use cache if possible\n  if ((cachedFiltersByChart[sliceId] || {}) === filters && (\n  colorScheme == null ||\n  cachedFormdataByChart[sliceId].color_scheme === colorScheme) &&\n  cachedFormdataByChart[sliceId].color_namespace === colorNamespace &&\n  _isEqual(cachedFormdataByChart[sliceId].label_colors, labelColors) &&\n  !!cachedFormdataByChart[sliceId] &&\n  nativeFilters === undefined) {\n    return cachedFormdataByChart[sliceId];\n  }\n  const formData = {\n    ...chart.formData,\n    ...(colorScheme && { color_scheme: colorScheme }),\n    label_colors: labelColors,\n    extra_filters: getEffectiveExtraFilters(filters),\n    extra_form_data: getExtraFormData(nativeFilters) };\n\n  cachedFiltersByChart[sliceId] = filters;\n  cachedFormdataByChart[sliceId] = formData;\n  return formData;\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(cachedFiltersByChart, \"cachedFiltersByChart\", \"/app/superset-frontend/src/dashboard/util/charts/getFormDataWithExtraFilters.ts\");reactHotLoader.register(cachedFormdataByChart, \"cachedFormdataByChart\", \"/app/superset-frontend/src/dashboard/util/charts/getFormDataWithExtraFilters.ts\");reactHotLoader.register(getFormDataWithExtraFilters, \"getFormDataWithExtraFilters\", \"/app/superset-frontend/src/dashboard/util/charts/getFormDataWithExtraFilters.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/app/superset-frontend/src/dashboard/util/charts/getFormDataWithExtraFilters.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAmBA,SACE,yBADF,QAGO,mBAHP;AAMA,SAAS,gBAAT,QAAiC,8CAAjC;AACA,OAAO,wBAAP,MAAqC,4BAArC;AAEA;AACA;AACA,MAAM,oBAAoB,GAAG,EAA7B;AACA,MAAM,qBAAqB,GAAG,EAA9B;AAWA;AACA;AACA;AACA,eAAc,SAAU,2BAAV,CAAsC,EAClD,KADkD,EAElD,OAFkD,EAGlD,WAHkD,EAIlD,cAJkD,EAKlD,OALkD,EAMlD,aANkD,EAAtC,EAOyB;AACrC;AACA,QAAM,KAAK,GAAG,yBAAyB,CAAC,QAA1B,CAAmC,WAAnC,EAAgD,cAAhD,CAAd;AACA,QAAM,WAAW,GAAG,KAAK,CAAC,WAAN,EAApB;AAEA;AACA,MACE,CAAC,oBAAoB,CAAC,OAAD,CAApB,IAAiC,EAAlC,MAA0C,OAA1C;AACC,EAAA,WAAW,IAAI,IAAf;AACC,EAAA,qBAAqB,CAAC,OAAD,CAArB,CAA+B,YAA/B,KAAgD,WAFlD;AAGA,EAAA,qBAAqB,CAAC,OAAD,CAArB,CAA+B,eAA/B,KAAmD,cAHnD;AAIA,WAAQ,qBAAqB,CAAC,OAAD,CAArB,CAA+B,YAAvC,EAAqD,WAArD,CAJA;AAKA,GAAC,CAAC,qBAAqB,CAAC,OAAD,CALvB;AAMA,EAAA,aAAa,KAAK,SAPpB,EAQE;AACA,WAAO,qBAAqB,CAAC,OAAD,CAA5B;AACD;AAED,QAAM,QAAQ,GAAG;AACf,OAAG,KAAK,CAAC,QADM;AAEf,QAAI,WAAW,IAAI,EAAE,YAAY,EAAE,WAAhB,EAAnB,CAFe;AAGf,IAAA,YAAY,EAAE,WAHC;AAIf,IAAA,aAAa,EAAE,wBAAwB,CAAC,OAAD,CAJxB;AAKf,IAAA,eAAe,EAAE,gBAAgB,CAAC,aAAD,CALlB,EAAjB;;AAOA,EAAA,oBAAoB,CAAC,OAAD,CAApB,GAAgC,OAAhC;AACA,EAAA,qBAAqB,CAAC,OAAD,CAArB,GAAiC,QAAjC;AAEA,SAAO,QAAP;AACD,C,iLAnDK,oB,qIACA,qB,sIAckB,2B","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { isEqual } from 'lodash';\nimport {\n  CategoricalColorNamespace,\n  DataRecordFilters,\n} from '@superset-ui/core';\nimport { ChartQueryPayload } from 'src/dashboard/types';\nimport { NativeFiltersState } from 'src/dashboard/components/nativeFilters/types';\nimport { getExtraFormData } from 'src/dashboard/components/nativeFilters/utils';\nimport getEffectiveExtraFilters from './getEffectiveExtraFilters';\n\n// We cache formData objects so that our connected container components don't always trigger\n// render cascades. we cannot leverage the reselect library because our cache size is >1\nconst cachedFiltersByChart = {};\nconst cachedFormdataByChart = {};\n\ninterface GetFormDataWithExtraFiltersArguments {\n  chart: ChartQueryPayload;\n  filters: DataRecordFilters;\n  colorScheme?: string;\n  colorNamespace?: string;\n  sliceId: number;\n  nativeFilters: NativeFiltersState;\n}\n\n// this function merge chart's formData with dashboard filters value,\n// and generate a new formData which will be used in the new query.\n// filters param only contains those applicable to this chart.\nexport default function getFormDataWithExtraFilters({\n  chart,\n  filters,\n  colorScheme,\n  colorNamespace,\n  sliceId,\n  nativeFilters,\n}: GetFormDataWithExtraFiltersArguments) {\n  // Propagate color mapping to chart\n  const scale = CategoricalColorNamespace.getScale(colorScheme, colorNamespace);\n  const labelColors = scale.getColorMap();\n\n  // if dashboard metadata + filters have not changed, use cache if possible\n  if (\n    (cachedFiltersByChart[sliceId] || {}) === filters &&\n    (colorScheme == null ||\n      cachedFormdataByChart[sliceId].color_scheme === colorScheme) &&\n    cachedFormdataByChart[sliceId].color_namespace === colorNamespace &&\n    isEqual(cachedFormdataByChart[sliceId].label_colors, labelColors) &&\n    !!cachedFormdataByChart[sliceId] &&\n    nativeFilters === undefined\n  ) {\n    return cachedFormdataByChart[sliceId];\n  }\n\n  const formData = {\n    ...chart.formData,\n    ...(colorScheme && { color_scheme: colorScheme }),\n    label_colors: labelColors,\n    extra_filters: getEffectiveExtraFilters(filters),\n    extra_form_data: getExtraFormData(nativeFilters),\n  };\n  cachedFiltersByChart[sliceId] = filters;\n  cachedFormdataByChart[sliceId] = formData;\n\n  return formData;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}