{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";import _concatInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/concat\";import _Object$entries from \"@babel/runtime-corejs3/core-js-stable/object/entries\";import _Array$isArray from \"@babel/runtime-corejs3/core-js-stable/array/is-array\";import _indexOfInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/index-of\";import _filterInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/filter\";import _mapInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/map\";import _flatInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/flat\";import _findInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/find\";import _Object$keys from \"@babel/runtime-corejs3/core-js-stable/object/keys\";import _forEachInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/for-each\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport memoizeOne from 'memoize-one';\nimport { getChartControlPanelRegistry } from '@superset-ui/core';\nimport { expandControlConfig } from '@superset-ui/chart-controls';\nimport * as SECTIONS from './controlPanels/sections';\n\nexport function getFormDataFromControls(controlsState) {var _context;\n  const formData = {};\n  _forEachInstanceProperty(_context = _Object$keys(controlsState)).call(_context, controlName => {\n    const control = controlsState[controlName];\n    formData[controlName] = control.value;\n  });\n  return formData;\n}\n\nexport function validateControl(control, processedState) {\n  const { validators } = control;\n  const validationErrors = [];\n  if (validators && validators.length > 0) {\n    _forEachInstanceProperty(validators).call(validators, f => {\n      const v = f.call(control, control.value, processedState);\n      if (v) {\n        validationErrors.push(v);\n      }\n    });\n  }\n  // always reset validation errors even when there is no validator\n  return { ...control, validationErrors };\n}\n\n/**\n * Find control item from control panel config.\n */\nexport function findControlItem(controlPanelSections, controlKey) {var _controlPanelSections, _context2, _context3;\n  return (_controlPanelSections =\n  _findInstanceProperty(_context2 = _flatInstanceProperty(_context3 = _mapInstanceProperty(controlPanelSections).call(controlPanelSections,\n  section => section.controlSetRows)).call(_context3,\n  2)).call(_context2,\n\n  (control) =>\n  controlKey === control ||\n  control !== null &&\n  typeof control === 'object' &&\n  control.name === controlKey)) != null ? _controlPanelSections :\n  null;\n\n}\n\nconst getMemoizedControlConfig = memoizeOne(\n(controlKey, controlPanelConfig) => {\n  const {\n    controlOverrides = {},\n    controlPanelSections = [] } =\n  controlPanelConfig;\n\n  const control = expandControlConfig(\n  findControlItem(controlPanelSections, controlKey),\n  controlOverrides);\n\n  return (control == null ? void 0 : control.config) || control;\n});\n\n\nexport const getControlConfig = function getControlConfig(controlKey, vizType) {\n  const controlPanelConfig = getChartControlPanelRegistry().get(vizType) || {};\n  return getMemoizedControlConfig(controlKey, controlPanelConfig);\n};\n\nfunction handleMissingChoice(control) {\n  // If the value is not valid anymore based on choices, clear it\n  const { value } = control;\n  if (\n  control.type === 'SelectControl' &&\n  !control.freeForm &&\n  control.choices &&\n  value)\n  {var _context4;\n    const alteredControl = { ...control };\n    const choiceValues = _mapInstanceProperty(_context4 = control.choices).call(_context4, c => c[0]);\n    if (control.multi && value.length > 0) {\n      alteredControl.value = _filterInstanceProperty(value).call(value, el => _indexOfInstanceProperty(choiceValues).call(choiceValues, el) > -1);\n      return alteredControl;\n    }\n    if (!control.multi && _indexOfInstanceProperty(choiceValues).call(choiceValues, value) < 0) {\n      alteredControl.value = null;\n      return alteredControl;\n    }\n  }\n  return control;\n}\n\nexport function applyMapStateToPropsToControl(controlState, controlPanelState) {\n  const { mapStateToProps } = controlState;\n  let state = { ...controlState };\n  let { value } = state; // value is current user-input value\n  if (mapStateToProps && controlPanelState) {\n    state = {\n      ...controlState,\n      ...mapStateToProps(controlPanelState, controlState) };\n\n    // `mapStateToProps` may also provide a value\n    value = value || state.value;\n  }\n  // If default is a function, evaluate it\n  if (typeof state.default === 'function') {\n    state.default = state.default(state, controlPanelState);\n    // if default is still a function, discard\n    if (typeof state.default === 'function') {\n      delete state.default;\n    }\n  }\n  // If no current value, set it as default\n  if (state.default && value === undefined) {\n    value = state.default;\n  }\n  // If a choice control went from multi=false to true, wrap value in array\n  if (value && state.multi && !_Array$isArray(value)) {\n    value = [value];\n  }\n  state.value = value;\n  return validateControl(handleMissingChoice(state), state);\n}\n\nexport function getControlStateFromControlConfig(\ncontrolConfig,\ncontrolPanelState,\nvalue)\n{\n  // skip invalid config values\n  if (!controlConfig) {\n    return null;\n  }\n  const controlState = { ...controlConfig, value };\n  // only apply mapStateToProps when control states have been initialized\n  // or when explicitly didn't provide control panel state (mostly for testing)\n  if (\n  controlPanelState && controlPanelState.controls ||\n  controlPanelState === null)\n  {\n    return applyMapStateToPropsToControl(controlState, controlPanelState);\n  }\n  return controlState;\n}\n\nexport function getControlState(controlKey, vizType, state, value) {\n  return getControlStateFromControlConfig(\n  getControlConfig(controlKey, vizType),\n  state,\n  value);\n\n}\n\nconst getMemoizedSectionsToRender = memoizeOne(\n(datasourceType, controlPanelConfig) => {var _context5, _context6, _context7, _context8;\n  const {\n    sectionOverrides = {},\n    controlOverrides,\n    controlPanelSections = [] } =\n  controlPanelConfig;\n\n  // default control panel sections\n  const sections = { ...SECTIONS };\n\n  // apply section overrides\n  _forEachInstanceProperty(_context5 = _Object$entries(sectionOverrides)).call(_context5, ([section, overrides]) => {\n    if (typeof overrides === 'object' && overrides.constructor === Object) {\n      sections[section] = {\n        ...sections[section],\n        ...overrides };\n\n    } else {\n      sections[section] = overrides;\n    }\n  });\n\n  const { datasourceAndVizType } = sections;\n  // list of datasource-specific controls that should be removed\n  const invalidControls =\n  datasourceType === 'table' ?\n  ['granularity', 'druid_time_origin'] :\n  ['granularity_sqla', 'time_grain_sqla'];\n\n  return _mapInstanceProperty(_context6 = _filterInstanceProperty(_context7 = _concatInstanceProperty(_context8 = []).call(_context8,\n  datasourceAndVizType, controlPanelSections)).call(_context7,\n  section => !!section)).call(_context6,\n  section => {\n    const { controlSetRows } = section;\n    return {\n      ...section,\n      controlSetRows:\n      (controlSetRows == null ? void 0 : _mapInstanceProperty(controlSetRows).call(controlSetRows, row => {var _context9;return (\n          _mapInstanceProperty(_context9 = _filterInstanceProperty(row).call(row,\n          control => !_includesInstanceProperty(invalidControls).call(invalidControls, control))).call(_context9,\n          item => expandControlConfig(item, controlOverrides)));})) ||\n      [] };\n\n  });\n});\n\n\n/**\n * Get the clean and processed control panel sections\n */\nexport const sectionsToRender = function sectionsToRender(\nvizType,\ndatasourceType)\n{\n  const controlPanelConfig = getChartControlPanelRegistry().get(vizType) || {};\n  return getMemoizedSectionsToRender(datasourceType, controlPanelConfig);\n};\n\nexport function getAllControlsState(vizType, datasourceType, state, formData) {var _context10;\n  const controlsState = {};\n  _forEachInstanceProperty(_context10 = sectionsToRender(vizType, datasourceType)).call(_context10, section => {var _context11;return (\n      _forEachInstanceProperty(_context11 = section.controlSetRows).call(_context11, (fieldsetRow) =>\n      _forEachInstanceProperty(fieldsetRow).call(fieldsetRow, field => {\n        if (field && field.config && field.name) {\n          const { config, name } = field;\n          controlsState[name] = getControlStateFromControlConfig(\n          config,\n          state,\n          formData[name]);\n\n        }\n      })));});\n\n\n  return controlsState;\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(getFormDataFromControls, \"getFormDataFromControls\", \"/app/superset-frontend/src/explore/controlUtils.js\");reactHotLoader.register(validateControl, \"validateControl\", \"/app/superset-frontend/src/explore/controlUtils.js\");reactHotLoader.register(findControlItem, \"findControlItem\", \"/app/superset-frontend/src/explore/controlUtils.js\");reactHotLoader.register(getMemoizedControlConfig, \"getMemoizedControlConfig\", \"/app/superset-frontend/src/explore/controlUtils.js\");reactHotLoader.register(getControlConfig, \"getControlConfig\", \"/app/superset-frontend/src/explore/controlUtils.js\");reactHotLoader.register(handleMissingChoice, \"handleMissingChoice\", \"/app/superset-frontend/src/explore/controlUtils.js\");reactHotLoader.register(applyMapStateToPropsToControl, \"applyMapStateToPropsToControl\", \"/app/superset-frontend/src/explore/controlUtils.js\");reactHotLoader.register(getControlStateFromControlConfig, \"getControlStateFromControlConfig\", \"/app/superset-frontend/src/explore/controlUtils.js\");reactHotLoader.register(getControlState, \"getControlState\", \"/app/superset-frontend/src/explore/controlUtils.js\");reactHotLoader.register(getMemoizedSectionsToRender, \"getMemoizedSectionsToRender\", \"/app/superset-frontend/src/explore/controlUtils.js\");reactHotLoader.register(sectionsToRender, \"sectionsToRender\", \"/app/superset-frontend/src/explore/controlUtils.js\");reactHotLoader.register(getAllControlsState, \"getAllControlsState\", \"/app/superset-frontend/src/explore/controlUtils.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/app/superset-frontend/src/explore/controlUtils.js"],"names":["memoizeOne","getChartControlPanelRegistry","expandControlConfig","SECTIONS","getFormDataFromControls","controlsState","formData","controlName","control","value","validateControl","processedState","validators","validationErrors","length","f","v","call","push","findControlItem","controlPanelSections","controlKey","section","controlSetRows","name","getMemoizedControlConfig","controlPanelConfig","controlOverrides","config","getControlConfig","vizType","get","handleMissingChoice","type","freeForm","choices","alteredControl","choiceValues","c","multi","el","applyMapStateToPropsToControl","controlState","controlPanelState","mapStateToProps","state","default","undefined","getControlStateFromControlConfig","controlConfig","controls","getControlState","getMemoizedSectionsToRender","datasourceType","sectionOverrides","sections","overrides","constructor","Object","datasourceAndVizType","invalidControls","row","item","sectionsToRender","getAllControlsState","fieldsetRow","field"],"mappings":"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","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport memoizeOne from 'memoize-one';\nimport { getChartControlPanelRegistry } from '@superset-ui/core';\nimport { expandControlConfig } from '@superset-ui/chart-controls';\nimport * as SECTIONS from './controlPanels/sections';\n\nexport function getFormDataFromControls(controlsState) {\n  const formData = {};\n  Object.keys(controlsState).forEach(controlName => {\n    const control = controlsState[controlName];\n    formData[controlName] = control.value;\n  });\n  return formData;\n}\n\nexport function validateControl(control, processedState) {\n  const { validators } = control;\n  const validationErrors = [];\n  if (validators && validators.length > 0) {\n    validators.forEach(f => {\n      const v = f.call(control, control.value, processedState);\n      if (v) {\n        validationErrors.push(v);\n      }\n    });\n  }\n  // always reset validation errors even when there is no validator\n  return { ...control, validationErrors };\n}\n\n/**\n * Find control item from control panel config.\n */\nexport function findControlItem(controlPanelSections, controlKey) {\n  return (\n    controlPanelSections\n      .map(section => section.controlSetRows)\n      .flat(2)\n      .find(\n        control =>\n          controlKey === control ||\n          (control !== null &&\n            typeof control === 'object' &&\n            control.name === controlKey),\n      ) ?? null\n  );\n}\n\nconst getMemoizedControlConfig = memoizeOne(\n  (controlKey, controlPanelConfig) => {\n    const {\n      controlOverrides = {},\n      controlPanelSections = [],\n    } = controlPanelConfig;\n\n    const control = expandControlConfig(\n      findControlItem(controlPanelSections, controlKey),\n      controlOverrides,\n    );\n    return control?.config || control;\n  },\n);\n\nexport const getControlConfig = function getControlConfig(controlKey, vizType) {\n  const controlPanelConfig = getChartControlPanelRegistry().get(vizType) || {};\n  return getMemoizedControlConfig(controlKey, controlPanelConfig);\n};\n\nfunction handleMissingChoice(control) {\n  // If the value is not valid anymore based on choices, clear it\n  const { value } = control;\n  if (\n    control.type === 'SelectControl' &&\n    !control.freeForm &&\n    control.choices &&\n    value\n  ) {\n    const alteredControl = { ...control };\n    const choiceValues = control.choices.map(c => c[0]);\n    if (control.multi && value.length > 0) {\n      alteredControl.value = value.filter(el => choiceValues.indexOf(el) > -1);\n      return alteredControl;\n    }\n    if (!control.multi && choiceValues.indexOf(value) < 0) {\n      alteredControl.value = null;\n      return alteredControl;\n    }\n  }\n  return control;\n}\n\nexport function applyMapStateToPropsToControl(controlState, controlPanelState) {\n  const { mapStateToProps } = controlState;\n  let state = { ...controlState };\n  let { value } = state; // value is current user-input value\n  if (mapStateToProps && controlPanelState) {\n    state = {\n      ...controlState,\n      ...mapStateToProps(controlPanelState, controlState),\n    };\n    // `mapStateToProps` may also provide a value\n    value = value || state.value;\n  }\n  // If default is a function, evaluate it\n  if (typeof state.default === 'function') {\n    state.default = state.default(state, controlPanelState);\n    // if default is still a function, discard\n    if (typeof state.default === 'function') {\n      delete state.default;\n    }\n  }\n  // If no current value, set it as default\n  if (state.default && value === undefined) {\n    value = state.default;\n  }\n  // If a choice control went from multi=false to true, wrap value in array\n  if (value && state.multi && !Array.isArray(value)) {\n    value = [value];\n  }\n  state.value = value;\n  return validateControl(handleMissingChoice(state), state);\n}\n\nexport function getControlStateFromControlConfig(\n  controlConfig,\n  controlPanelState,\n  value,\n) {\n  // skip invalid config values\n  if (!controlConfig) {\n    return null;\n  }\n  const controlState = { ...controlConfig, value };\n  // only apply mapStateToProps when control states have been initialized\n  // or when explicitly didn't provide control panel state (mostly for testing)\n  if (\n    (controlPanelState && controlPanelState.controls) ||\n    controlPanelState === null\n  ) {\n    return applyMapStateToPropsToControl(controlState, controlPanelState);\n  }\n  return controlState;\n}\n\nexport function getControlState(controlKey, vizType, state, value) {\n  return getControlStateFromControlConfig(\n    getControlConfig(controlKey, vizType),\n    state,\n    value,\n  );\n}\n\nconst getMemoizedSectionsToRender = memoizeOne(\n  (datasourceType, controlPanelConfig) => {\n    const {\n      sectionOverrides = {},\n      controlOverrides,\n      controlPanelSections = [],\n    } = controlPanelConfig;\n\n    // default control panel sections\n    const sections = { ...SECTIONS };\n\n    // apply section overrides\n    Object.entries(sectionOverrides).forEach(([section, overrides]) => {\n      if (typeof overrides === 'object' && overrides.constructor === Object) {\n        sections[section] = {\n          ...sections[section],\n          ...overrides,\n        };\n      } else {\n        sections[section] = overrides;\n      }\n    });\n\n    const { datasourceAndVizType } = sections;\n    // list of datasource-specific controls that should be removed\n    const invalidControls =\n      datasourceType === 'table'\n        ? ['granularity', 'druid_time_origin']\n        : ['granularity_sqla', 'time_grain_sqla'];\n\n    return []\n      .concat(datasourceAndVizType, controlPanelSections)\n      .filter(section => !!section)\n      .map(section => {\n        const { controlSetRows } = section;\n        return {\n          ...section,\n          controlSetRows:\n            controlSetRows?.map(row =>\n              row\n                .filter(control => !invalidControls.includes(control))\n                .map(item => expandControlConfig(item, controlOverrides)),\n            ) || [],\n        };\n      });\n  },\n);\n\n/**\n * Get the clean and processed control panel sections\n */\nexport const sectionsToRender = function sectionsToRender(\n  vizType,\n  datasourceType,\n) {\n  const controlPanelConfig = getChartControlPanelRegistry().get(vizType) || {};\n  return getMemoizedSectionsToRender(datasourceType, controlPanelConfig);\n};\n\nexport function getAllControlsState(vizType, datasourceType, state, formData) {\n  const controlsState = {};\n  sectionsToRender(vizType, datasourceType).forEach(section =>\n    section.controlSetRows.forEach(fieldsetRow =>\n      fieldsetRow.forEach(field => {\n        if (field && field.config && field.name) {\n          const { config, name } = field;\n          controlsState[name] = getControlStateFromControlConfig(\n            config,\n            state,\n            formData[name],\n          );\n        }\n      }),\n    ),\n  );\n  return controlsState;\n}\n"]},"metadata":{},"sourceType":"module"}