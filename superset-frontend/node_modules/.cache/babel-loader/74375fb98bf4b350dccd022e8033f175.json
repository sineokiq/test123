{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";import _someInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/some\";import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";import _mapInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/map\";import _concatInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/concat\";import _filterInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/filter\";import _Object$values from \"@babel/runtime-corejs3/core-js-stable/object/values\";import _Object$entries from \"@babel/runtime-corejs3/core-js-stable/object/entries\";import _everyInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/every\";import _isEmpty from \"lodash/isEmpty\";import _flatMap from \"lodash/flatMap\";import _mapValues from \"lodash/fp/mapValues\";import _keyBy from \"lodash/fp/keyBy\";import _flow from \"lodash/fp/flow\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { CHART_TYPE, TAB_TYPE } from './componentTypes';\nimport { getChartIdAndColumnFromFilterKey } from './getDashboardFilterKey';\n\nfunction getTabChildrenScope({\n  tabScopes,\n  parentNodeValue,\n  forceAggregate = false,\n  hasChartSiblings = false,\n  immuneChartSiblings = [] })\n{var _context, _context2, _context3;\n  // if all sub-tabs are in scope, or forceAggregate =  true\n  // aggregate scope to parentNodeValue\n  if (\n  forceAggregate ||\n  !hasChartSiblings &&\n  _everyInstanceProperty(_context = _Object$entries(tabScopes)).call(_context,\n  ([key, { scope }]) => scope && scope.length && key === scope[0]))\n\n  {\n    return {\n      scope: [parentNodeValue],\n      immune: _flatMap(_Object$values(tabScopes), ({ immune }) => immune) };\n\n  }\n\n  const componentsInScope = _filterInstanceProperty(_context2 = _Object$values(tabScopes)).call(_context2,\n  ({ scope }) => scope && scope.length);\n\n  return {\n    scope: _flatMap(componentsInScope, ({ scope }) => scope),\n    immune: componentsInScope.length ?\n    _flatMap(componentsInScope, ({ immune }) => immune) :\n    _concatInstanceProperty(_context3 = _flatMap(_Object$values(tabScopes), ({ immune }) => immune)).call(_context3,\n    immuneChartSiblings) };\n\n\n}\n\nfunction traverse({ currentNode = {}, filterId, checkedChartIds = [] }) {var _context4;\n  if (!currentNode) {\n    return {};\n  }\n\n  const { value: currentValue, children } = currentNode;\n  const chartChildren = _filterInstanceProperty(children).call(children, ({ type }) => type === CHART_TYPE);\n  const tabChildren = _filterInstanceProperty(children).call(children, ({ type }) => type === TAB_TYPE);\n\n  const chartsImmune = _mapInstanceProperty(_context4 = _filterInstanceProperty(chartChildren).call(chartChildren,\n\n  ({ value }) => filterId !== value && !_includesInstanceProperty(checkedChartIds).call(checkedChartIds, value))).call(_context4,\n\n  ({ value }) => value);\n  const tabScopes = _flow(\n  _keyBy(child => child.value),\n  _mapValues((child) =>\n  traverse({\n    currentNode: child,\n    filterId,\n    checkedChartIds })))(\n\n\n  tabChildren);\n\n  // if any chart type child is in scope,\n  // no matter has tab children or not, current node should be scope\n  if (\n  !_isEmpty(chartChildren) &&\n  _someInstanceProperty(chartChildren).call(chartChildren, ({ value }) => _includesInstanceProperty(checkedChartIds).call(checkedChartIds, value)))\n  {\n    if (_isEmpty(tabChildren)) {\n      return { scope: [currentValue], immune: chartsImmune };\n    }\n\n    const { scope, immune } = getTabChildrenScope({\n      tabScopes,\n      parentNodeValue: currentValue,\n      forceAggregate: true });\n\n    return {\n      scope,\n      immune: _concatInstanceProperty(chartsImmune).call(chartsImmune, immune) };\n\n  }\n\n  // has tab children but only some sub-tab in scope\n  if (tabChildren.length) {\n    return getTabChildrenScope({\n      tabScopes,\n      parentNodeValue: currentValue,\n      hasChartSiblings: !_isEmpty(chartChildren),\n      immuneChartSiblings: chartsImmune });\n\n  }\n\n  // no tab children and no chart children in scope\n  return {\n    scope: [],\n    immune: chartsImmune };\n\n}\n\nexport default function getFilterScopeFromNodesTree({\n  filterKey,\n  nodes = [],\n  checkedChartIds = [] })\n{\n  if (nodes.length) {\n    const { chartId } = getChartIdAndColumnFromFilterKey(filterKey);\n    return traverse({\n      currentNode: nodes[0],\n      filterId: chartId,\n      checkedChartIds });\n\n  }\n\n  return {};\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(getTabChildrenScope, \"getTabChildrenScope\", \"/app/superset-frontend/src/dashboard/util/getFilterScopeFromNodesTree.js\");reactHotLoader.register(traverse, \"traverse\", \"/app/superset-frontend/src/dashboard/util/getFilterScopeFromNodesTree.js\");reactHotLoader.register(getFilterScopeFromNodesTree, \"getFilterScopeFromNodesTree\", \"/app/superset-frontend/src/dashboard/util/getFilterScopeFromNodesTree.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/app/superset-frontend/src/dashboard/util/getFilterScopeFromNodesTree.js"],"names":["CHART_TYPE","TAB_TYPE","getChartIdAndColumnFromFilterKey","getTabChildrenScope","tabScopes","parentNodeValue","forceAggregate","hasChartSiblings","immuneChartSiblings","key","scope","length","immune","componentsInScope","traverse","currentNode","filterId","checkedChartIds","value","currentValue","children","chartChildren","type","tabChildren","chartsImmune","child","getFilterScopeFromNodesTree","filterKey","nodes","chartId"],"mappings":"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","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { flow, keyBy, mapValues } from 'lodash/fp';\nimport { flatMap, isEmpty } from 'lodash';\n\nimport { CHART_TYPE, TAB_TYPE } from './componentTypes';\nimport { getChartIdAndColumnFromFilterKey } from './getDashboardFilterKey';\n\nfunction getTabChildrenScope({\n  tabScopes,\n  parentNodeValue,\n  forceAggregate = false,\n  hasChartSiblings = false,\n  immuneChartSiblings = [],\n}) {\n  // if all sub-tabs are in scope, or forceAggregate =  true\n  // aggregate scope to parentNodeValue\n  if (\n    forceAggregate ||\n    (!hasChartSiblings &&\n      Object.entries(tabScopes).every(\n        ([key, { scope }]) => scope && scope.length && key === scope[0],\n      ))\n  ) {\n    return {\n      scope: [parentNodeValue],\n      immune: flatMap(Object.values(tabScopes), ({ immune }) => immune),\n    };\n  }\n\n  const componentsInScope = Object.values(tabScopes).filter(\n    ({ scope }) => scope && scope.length,\n  );\n  return {\n    scope: flatMap(componentsInScope, ({ scope }) => scope),\n    immune: componentsInScope.length\n      ? flatMap(componentsInScope, ({ immune }) => immune)\n      : flatMap(Object.values(tabScopes), ({ immune }) => immune).concat(\n          immuneChartSiblings,\n        ),\n  };\n}\n\nfunction traverse({ currentNode = {}, filterId, checkedChartIds = [] }) {\n  if (!currentNode) {\n    return {};\n  }\n\n  const { value: currentValue, children } = currentNode;\n  const chartChildren = children.filter(({ type }) => type === CHART_TYPE);\n  const tabChildren = children.filter(({ type }) => type === TAB_TYPE);\n\n  const chartsImmune = chartChildren\n    .filter(\n      ({ value }) => filterId !== value && !checkedChartIds.includes(value),\n    )\n    .map(({ value }) => value);\n  const tabScopes = flow(\n    keyBy(child => child.value),\n    mapValues(child =>\n      traverse({\n        currentNode: child,\n        filterId,\n        checkedChartIds,\n      }),\n    ),\n  )(tabChildren);\n\n  // if any chart type child is in scope,\n  // no matter has tab children or not, current node should be scope\n  if (\n    !isEmpty(chartChildren) &&\n    chartChildren.some(({ value }) => checkedChartIds.includes(value))\n  ) {\n    if (isEmpty(tabChildren)) {\n      return { scope: [currentValue], immune: chartsImmune };\n    }\n\n    const { scope, immune } = getTabChildrenScope({\n      tabScopes,\n      parentNodeValue: currentValue,\n      forceAggregate: true,\n    });\n    return {\n      scope,\n      immune: chartsImmune.concat(immune),\n    };\n  }\n\n  // has tab children but only some sub-tab in scope\n  if (tabChildren.length) {\n    return getTabChildrenScope({\n      tabScopes,\n      parentNodeValue: currentValue,\n      hasChartSiblings: !isEmpty(chartChildren),\n      immuneChartSiblings: chartsImmune,\n    });\n  }\n\n  // no tab children and no chart children in scope\n  return {\n    scope: [],\n    immune: chartsImmune,\n  };\n}\n\nexport default function getFilterScopeFromNodesTree({\n  filterKey,\n  nodes = [],\n  checkedChartIds = [],\n}) {\n  if (nodes.length) {\n    const { chartId } = getChartIdAndColumnFromFilterKey(filterKey);\n    return traverse({\n      currentNode: nodes[0],\n      filterId: chartId,\n      checkedChartIds,\n    });\n  }\n\n  return {};\n}\n"]},"metadata":{},"sourceType":"module"}