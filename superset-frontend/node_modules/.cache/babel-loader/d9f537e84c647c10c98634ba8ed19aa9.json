{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";import _setTimeout from \"@babel/runtime-corejs3/core-js-stable/set-timeout\";import _Array$isArray from \"@babel/runtime-corejs3/core-js-stable/array/is-array\";import _Promise from \"@babel/runtime-corejs3/core-js-stable/promise\";import _forEachInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/for-each\";import _reduceInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/reduce\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};import { makeApi, SupersetClient } from '@superset-ui/core';\nimport { FeatureFlag, isFeatureEnabled } from '../featureFlags';\nimport { getClientErrorObject, parseErrorJson } from '../utils/getClientErrorObject';\nconst initAsyncEvents = options => {\n  // TODO: implement websocket support\n  const TRANSPORT_POLLING = 'polling';\n  const { config, getPendingComponents, successAction, errorAction, processEventsCallback } = options;\n  const transport = config.GLOBAL_ASYNC_QUERIES_TRANSPORT || TRANSPORT_POLLING;\n  const polling_delay = config.GLOBAL_ASYNC_QUERIES_POLLING_DELAY || 500;\n  const middleware = store => next => {\n    const JOB_STATUS = {\n      PENDING: 'pending',\n      RUNNING: 'running',\n      ERROR: 'error',\n      DONE: 'done' };\n\n    const LOCALSTORAGE_KEY = 'last_async_event_id';\n    const POLLING_URL = '/api/v1/async_event/';\n    let lastReceivedEventId;\n    try {\n      lastReceivedEventId = localStorage.getItem(LOCALSTORAGE_KEY);\n    }\n    catch (err) {\n      console.warn('Failed to fetch last event Id from localStorage');\n    }\n    const fetchEvents = makeApi({\n      method: 'GET',\n      endpoint: POLLING_URL });\n\n    const fetchCachedData = async (asyncEvent, componentId) => {\n      let status = 'success';\n      let data;\n      try {\n        const { json } = await SupersetClient.get({\n          endpoint: asyncEvent.result_url });\n\n        data = 'result' in json ? json.result : json;\n      }\n      catch (response) {\n        status = 'error';\n        data = await getClientErrorObject(response);\n      }\n      return { componentId, status, data };\n    };\n    const setLastId = asyncEvent => {\n      lastReceivedEventId = asyncEvent.id;\n      try {\n        localStorage.setItem(LOCALSTORAGE_KEY, lastReceivedEventId);\n      }\n      catch (err) {\n        console.warn('Error saving event Id to localStorage', err);\n      }\n    };\n    const processEvents = async () => {\n      const state = store.getState();\n      const queuedComponents = getPendingComponents(state);\n      const eventArgs = lastReceivedEventId ?\n      { last_id: lastReceivedEventId } :\n      {};\n      const events = [];\n      if (queuedComponents && queuedComponents.length) {\n        try {\n          const { result: events } = await fetchEvents(eventArgs);\n          if (events && events.length) {\n            const componentsByJobId = _reduceInstanceProperty(queuedComponents).call(queuedComponents, (acc, item) => {\n              acc[item.asyncJobId] = item;\n              return acc;\n            }, {});\n            const fetchDataEvents = [];\n            _forEachInstanceProperty(events).call(events, asyncEvent => {\n              const component = componentsByJobId[asyncEvent.job_id];\n              if (!component) {\n                console.warn('Component not found for job_id', asyncEvent.job_id);\n                return setLastId(asyncEvent);\n              }\n              const componentId = component.id;\n              switch (asyncEvent.status) {\n                case JOB_STATUS.DONE:\n                  fetchDataEvents.push(fetchCachedData(asyncEvent, componentId));\n                  break;\n                case JOB_STATUS.ERROR:\n                  store.dispatch(errorAction(componentId, [parseErrorJson(asyncEvent)]));\n                  break;\n                default:\n                  console.warn('Received event with status', asyncEvent.status);}\n\n              return setLastId(asyncEvent);\n            });\n            const fetchResults = await _Promise.all(fetchDataEvents);\n            _forEachInstanceProperty(fetchResults).call(fetchResults, result => {\n              const data = _Array$isArray(result.data) ?\n              result.data :\n              [result.data];\n              if (result.status === 'success') {\n                store.dispatch(successAction(result.componentId, data));\n              } else\n              {\n                store.dispatch(errorAction(result.componentId, data));\n              }\n            });\n          }\n        }\n        catch (err) {\n          console.warn(err);\n        }\n      }\n      if (processEventsCallback)\n      processEventsCallback(events);\n      return _setTimeout(processEvents, polling_delay);\n    };\n    if (isFeatureEnabled(FeatureFlag.GLOBAL_ASYNC_QUERIES) &&\n    transport === TRANSPORT_POLLING) {\n      processEvents();\n    }\n    return action => next(action);\n  };\n  return middleware;\n};const _default =\ninitAsyncEvents;export default _default;;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(initAsyncEvents, \"initAsyncEvents\", \"/app/superset-frontend/src/middleware/asyncEvent.ts\");reactHotLoader.register(_default, \"default\", \"/app/superset-frontend/src/middleware/asyncEvent.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/app/superset-frontend/src/middleware/asyncEvent.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { Dispatch, Middleware, MiddlewareAPI } from 'redux';\nimport { makeApi, SupersetClient } from '@superset-ui/core';\nimport { SupersetError } from 'src/components/ErrorMessage/types';\nimport { FeatureFlag, isFeatureEnabled } from '../featureFlags';\nimport {\n  getClientErrorObject,\n  parseErrorJson,\n} from '../utils/getClientErrorObject';\n\nexport type AsyncEvent = {\n  id: string;\n  channel_id: string;\n  job_id: string;\n  user_id: string;\n  status: string;\n  errors: SupersetError[];\n  result_url: string;\n};\n\ntype AsyncEventOptions = {\n  config: {\n    GLOBAL_ASYNC_QUERIES_TRANSPORT: string;\n    GLOBAL_ASYNC_QUERIES_POLLING_DELAY: number;\n  };\n  getPendingComponents: (state: any) => any[];\n  successAction: (componentId: number, componentData: any) => { type: string };\n  errorAction: (componentId: number, response: any) => { type: string };\n  processEventsCallback?: (events: AsyncEvent[]) => void; // this is currently used only for tests\n};\n\ntype CachedDataResponse = {\n  componentId: number;\n  status: string;\n  data: any;\n};\n\nconst initAsyncEvents = (options: AsyncEventOptions) => {\n  // TODO: implement websocket support\n  const TRANSPORT_POLLING = 'polling';\n  const {\n    config,\n    getPendingComponents,\n    successAction,\n    errorAction,\n    processEventsCallback,\n  } = options;\n  const transport = config.GLOBAL_ASYNC_QUERIES_TRANSPORT || TRANSPORT_POLLING;\n  const polling_delay = config.GLOBAL_ASYNC_QUERIES_POLLING_DELAY || 500;\n\n  const middleware: Middleware = (store: MiddlewareAPI) => (next: Dispatch) => {\n    const JOB_STATUS = {\n      PENDING: 'pending',\n      RUNNING: 'running',\n      ERROR: 'error',\n      DONE: 'done',\n    };\n    const LOCALSTORAGE_KEY = 'last_async_event_id';\n    const POLLING_URL = '/api/v1/async_event/';\n    let lastReceivedEventId: string | null;\n\n    try {\n      lastReceivedEventId = localStorage.getItem(LOCALSTORAGE_KEY);\n    } catch (err) {\n      console.warn('Failed to fetch last event Id from localStorage');\n    }\n\n    const fetchEvents = makeApi<\n      { last_id?: string | null },\n      { result: AsyncEvent[] }\n    >({\n      method: 'GET',\n      endpoint: POLLING_URL,\n    });\n\n    const fetchCachedData = async (\n      asyncEvent: AsyncEvent,\n      componentId: number,\n    ): Promise<CachedDataResponse> => {\n      let status = 'success';\n      let data;\n      try {\n        const { json } = await SupersetClient.get({\n          endpoint: asyncEvent.result_url,\n        });\n        data = 'result' in json ? json.result : json;\n      } catch (response) {\n        status = 'error';\n        data = await getClientErrorObject(response);\n      }\n\n      return { componentId, status, data };\n    };\n\n    const setLastId = (asyncEvent: AsyncEvent) => {\n      lastReceivedEventId = asyncEvent.id;\n      try {\n        localStorage.setItem(LOCALSTORAGE_KEY, lastReceivedEventId as string);\n      } catch (err) {\n        console.warn('Error saving event Id to localStorage', err);\n      }\n    };\n\n    const processEvents = async () => {\n      const state = store.getState();\n      const queuedComponents = getPendingComponents(state);\n      const eventArgs = lastReceivedEventId\n        ? { last_id: lastReceivedEventId }\n        : {};\n      const events: AsyncEvent[] = [];\n      if (queuedComponents && queuedComponents.length) {\n        try {\n          const { result: events } = await fetchEvents(eventArgs);\n          if (events && events.length) {\n            const componentsByJobId = queuedComponents.reduce((acc, item) => {\n              acc[item.asyncJobId] = item;\n              return acc;\n            }, {});\n            const fetchDataEvents: Promise<CachedDataResponse>[] = [];\n            events.forEach((asyncEvent: AsyncEvent) => {\n              const component = componentsByJobId[asyncEvent.job_id];\n              if (!component) {\n                console.warn(\n                  'Component not found for job_id',\n                  asyncEvent.job_id,\n                );\n                return setLastId(asyncEvent);\n              }\n              const componentId = component.id;\n              switch (asyncEvent.status) {\n                case JOB_STATUS.DONE:\n                  fetchDataEvents.push(\n                    fetchCachedData(asyncEvent, componentId),\n                  );\n                  break;\n                case JOB_STATUS.ERROR:\n                  store.dispatch(\n                    errorAction(componentId, [parseErrorJson(asyncEvent)]),\n                  );\n                  break;\n                default:\n                  console.warn('Received event with status', asyncEvent.status);\n              }\n\n              return setLastId(asyncEvent);\n            });\n\n            const fetchResults = await Promise.all(fetchDataEvents);\n            fetchResults.forEach(result => {\n              const data = Array.isArray(result.data)\n                ? result.data\n                : [result.data];\n              if (result.status === 'success') {\n                store.dispatch(successAction(result.componentId, data));\n              } else {\n                store.dispatch(errorAction(result.componentId, data));\n              }\n            });\n          }\n        } catch (err) {\n          console.warn(err);\n        }\n      }\n\n      if (processEventsCallback) processEventsCallback(events);\n\n      return setTimeout(processEvents, polling_delay);\n    };\n\n    if (\n      isFeatureEnabled(FeatureFlag.GLOBAL_ASYNC_QUERIES) &&\n      transport === TRANSPORT_POLLING\n    ) {\n      processEvents();\n    }\n\n    return action => next(action);\n  };\n\n  return middleware;\n};\n\nexport default initAsyncEvents;\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}